---
datePublished: 2024-06-08
draft: true
---

# Rounding numbers: Old new tricks

I recently implemented a new DDS decoder for [the `image` crate](https://github.com/image-rs/image). DDS is a container format that supports a variety of image formats (compressed and uncompressed) with the purpose of storing textures, volumes, cubemaps, and more for games and 3D applications. What's interesting about these image formats is that [the specification](https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm#Chapter19Contents) is written in terms of floating point numbers. This presents an interesting optimization problem for decoders that output 8-bit-per-channel images.

This article will focus on the `B5G6R5_UNORM` format. This is a 16-bit-per-pixel uncompressed (but quantized) RGB format. The R and B channels are 5 bits each, and the G channel is 6 bits. The formula for converting a n-bit number $x$ to 8 bit is:

$$
round(\frac{x}{2^n - 1} \cdot 255)
$$

Simple enough, here's the naive Rust implementation for converting a 5-bit number to an 8-bit number:

```rust
fn u5_to_u8_naive(x: u16) -> u8 {
    (x as f32 / 31.0 * 255.0).round() as u8
}
```

However, while talking to the maintainer of the `image` crate, he pointed me towards the direction of [the `bcdec` C library](https://github.com/iOrange/bcdec). So I took a peak at their code and found that they used this for the 5 bit to 8 bit conversion (here, translated to Rust):

```rust
fn u5_to_u8_bcdec(x: u16) -> u8 {
    ((x * 527 + 23) >> 6) as u8
}
```

Somehow, this random collection of operations produces the same results as the floating point version (for all 5-bit values of `x`), and it's about **20x** faster. C program(mer)s are just built different.

In this article, we will optimize our naive 5-to-8-bit conversion function all the way to the `bcdec` version. We'll also generalize the `bcdec` version to convert any `0..=S` number to any `0..=T` number for arbitrary `S` and `T`.

## Benchmarking

Before we start optimizing, let's define a benchmark.

Since the range of input values is very small (32 values), we'll just fill a `Vec<u16>` with 1024 random values between 0 and 31 and convert them to 8-bit values. Since our function is very simple, this means that we're benchmarking not only the function, but also how well the compiler can vectorize it. This is very close to what the DDS decoder I made does, so it decently represents a real-world use case.

<details>
<summary>The code</summary>

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use rand::prelude::*;
use rounding_rs::*;

fn define_benchmark(c: &mut Criterion, name: &str, f: impl Fn(u16) -> u8) {
    let mut rng = rand::thread_rng();
    const N: usize = 1024;
    let samples: Vec<u16> = black_box((0..N).map(|_| rng.gen_range(0..=31)).collect());
    let mut output = [0u8; N];

    c.bench_function(name, |b| {
        b.iter(|| {
            for (x, out) in samples.iter().zip(output.iter_mut()) {
                *out = f(*x);
            }
            black_box(output);
        })
    });
}

fn round_benchmark(c: &mut Criterion) {
    define_benchmark(c, "u5_to_u8_naive", u5_to_u8_naive);
    define_benchmark(c, "u5_to_u8_bcdec", u5_to_u8_bcdec);
}

criterion_group!(benches, round_benchmark);
criterion_main!(benches);
```

</details>

All benchmarks in this article were performed in the following environment:

-   OS: Windows 10
-   CPU: Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz
-   Rust: 1.78.0

Here are the results for the naive and `bcdec` versions. Note the _different units_.

```
u5_to_u8_naive          time:   [11.108 µs 11.147 µs 11.195 µs]
u5_to_u8_bcdec          time:   [527.47 ns 531.42 ns 536.16 ns]
```

Yep, 21.15x faster. Let's try to catch up.

## Optimizing the naive implementation

Let's start by taking a look at the assembly generated by the naive implementation. I'm using compiler explorer for this, so the assembly might be slightly different from what you get on your machine.

```rust
fn u5_to_u8_naive(x: u16) -> u8 {
    (x as f32 / 31.0 * 255.0).round() as u8
}
```

```asm
.LCPI0_0:
        .long   0x41f80000
.LCPI0_1:
        .long   0x437f0000
u5_to_u8_naive:
        push    rax
        movzx   eax, di
        cvtsi2ss        xmm0, eax                 ; xmm0 = x to f32
        divss   xmm0, dword ptr [rip + .LCPI0_0]  ; xmm0 = xmm0 / 31.0
        mulss   xmm0, dword ptr [rip + .LCPI0_1]  ; xmm0 = xmm0 * 255.0
        call    qword ptr [rip + roundf@GOTPCREL] ; xmm0 = round(xmm0)
        xorps   xmm1, xmm1                        ; xmm1 = 0.0
        maxss   xmm1, xmm0                        ; xmm1 = min(xmm1, xmm0)
        movss   xmm0, dword ptr [rip + .LCPI0_1]  ; xmm0 = 255.0
        minss   xmm0, xmm1                        ; xmm0 = max(xmm0, xmm1)
        cvttss2si       eax, xmm0                 ; convert xmm0 to u8
        pop     rcx
        ret
```

Well, that's not good. A few things to note:

1. The compiler did not optimize `/ 31.0 * 255.0` into a single multiplication.
2. `round` is a function call.
3. `as u8` does a surprising amount of work. It first clamps the float to the range 0-255, then converts it to an integer by truncation. So `f as u8` essentially does `f.clamp(0.0, 255.0).trunc() as u8`.

We can easily remove the division by defining a `const`ant for `255.0 / 31.0` and then multiplying with the constant. This is fairly trivial, so let's move on to more interesting optimizations.

Next: the call to `round`. Mathematically speaking, rounding is defined as follows:

$$
round(x) := \lfloor x + 0.5 \rfloor, \space x \in \R
$$

However, we are working with finitely precise 32-bit floating point numbers, where the result of `0.49999997 + 0.5` is `1.0`:

```rust
let a: f32 = 0.49999997;
assert!(a != 0.5);
assert!(a + 0.5 == 1.0);
assert!(a.round() == 0.0);
```

So Rust's `round` function has to do quite a bit of work to get the correct result.

But let's forget about all of this complexity again, and just pretend to live a mathemagical world where $round(x) = \lfloor x + 0.5 \rfloor$.

```rust
fn u5_to_u8_naive_v2_alpha(x: u16) -> u8 {
    const FACTOR: f32 = 255.0 / 31.0;
    (x as f32 * FACTOR + 0.5).floor() as u8
}
```

But wait! As we've seen in the assembly `as u8` _truncates_ our floating point number. Since $trunc(x) = \lfloor x \rfloor$ for all $x \ge 0$, we can just remove the `floor` call:

```rust
fn u5_to_u8_naive_v2(x: u16) -> u8 {
    const FACTOR: f32 = 255.0 / 31.0;
    (x as f32 * FACTOR + 0.5) as u8
}
```

```asm
.LCPI0_0:
        .long   0x41039ce7
.LCPI0_1:
        .long   0x3f000000
.LCPI0_2:
        .long   0x437f0000
u5_to_u8_naive_v2:
        movzx   eax, di
        cvtsi2ss        xmm0, eax                ; xmm0 = x to f32
        mulss   xmm0, dword ptr [rip + .LCPI0_0] ; xmm0 = xmm0 * 8.22580624 (255 / 31)
        addss   xmm0, dword ptr [rip + .LCPI0_1] ; xmm0 = xmm0 + 0.5
        xorps   xmm1, xmm1                       ; xmm1 = 0.0
        maxss   xmm1, xmm0                       ; xmm1 = min(xmm1, xmm0)
        movss   xmm0, dword ptr [rip + .LCPI0_2] ; xmm0 = 255.0
        minss   xmm0, xmm1                       ; xmm0 = max(xmm0, xmm1)
        cvttss2si       eax, xmm0                ; convert xmm0 to u8
        ret
```

```
u5_to_u8_naive          time:   [11.108 µs 11.147 µs 11.195 µs]
u5_to_u8_naive_v2       time:   [1.3806 µs 1.3848 µs 1.3898 µs]
u5_to_u8_bcdec          time:   [527.47 ns 531.42 ns 536.16 ns]
```

That's a lot better. Our optimizations made the naive implementation 8x faster. We got a lot more competitive with the `bcdec` version, but we're still not quite there.

The unnecessary clamping is next. Rust only performs the clamping to be safe, because it doesn't know that the floating point value is already between 0 and 255(.999). But we know that. Luckily, Rust provides us with the [`f32::to_int_unchecked`](https://doc.rust-lang.org/std/primitive.f32.html#method.to_int_unchecked) method to get around this.

```rust
/// ## Safety
/// The caller must ensure that x < 32.
unsafe fn u5_to_u8_naive_v3(x: u16) -> u8 {
    debug_assert!(x < 32);
    const FACTOR: f32 = 255.0 / 31.0;
    let f = x as f32 * FACTOR + 0.5;
    unsafe { f.to_int_unchecked() }
}
```

```asm
.LCPI0_0:
        .long   0x41039ce7
.LCPI0_1:
        .long   0x3f000000
u5_to_u8_naive_v3:
        movzx   eax, di
        cvtsi2ss        xmm0, eax                ; xmm0 = x to f32
        mulss   xmm0, dword ptr [rip + .LCPI0_0] ; xmm0 = xmm0 * 8.22580624 (255 / 31)
        addss   xmm0, dword ptr [rip + .LCPI0_1] ; xmm0 = xmm0 + 0.5
        cvttss2si       eax, xmm0                ; convert xmm0 to u8
        ret
```

```
u5_to_u8_naive          time:   [11.108 µs 11.147 µs 11.195 µs]
u5_to_u8_naive_v2       time:   [1.3806 µs 1.3848 µs 1.3898 µs]
u5_to_u8_naive_v3       time:   [614.04 ns 615.98 ns 618.32 ns]
u5_to_u8_bcdec          time:   [527.47 ns 531.42 ns 536.16 ns]
```

We're almost caught up. The `bcdec` version is still faster, but we're only 1.17x slower now.

However, we did have to use `unsafe`, which is never nice. Since the floating-point-to-integer conversion is the reason we needed `unsafe` in the first place, let's avoid using floating point altogether.

## Rounded division for unsigned integers

Before we tackle the 5 bit to 8 bit conversion, let's focus on rounded integer division first. Specifically, this:

$$
round(\frac{a}{b}), \space a, b \in \N_0, \space b \neq 0
$$

Using $round(x) = \lfloor x + 0.5 \rfloor$, we get:

$$
\begin{split}
round(\frac{a}{b}) & = \lfloor \frac{a}{b} + 0.5 \rfloor \\
                   & = \lfloor \frac{a}{b} + \frac{b/2}{b} \rfloor \\
                   & = \lfloor \frac{a + b/2}{b} \rfloor \\
                   & = \lfloor \frac{a + \lfloor b/2 \rfloor}{b} \rfloor \\
\end{split}
$$

Proof for the last step can be found in the appendix.

Since we now have integers in the denominator and divisor, we can use the standard integer division (which performs truncation):

```rust
fn div_rounded(a: u32, b: u32) -> u32 {
    (a + (b >> 1)) / b
}
```

Using this as a basis, we can implement the 5 bit to 8 bit conversion using only integer arithmetic:

```rust
fn u5_to_u8_int(x: u32) -> u8 {
    ((x * 255 + (31 >> 1)) / 31) as u8
}
```

```asm
u5_to_u8_int:
        mov     eax, edi            ; eax = x
        shl     eax, 8              ; eax = x << 8 (= x * 256)
        sub     eax, edi            ; eax = eax - x
        add     eax, 15             ; eax = eax + 15
        imul    rcx, rax, 138547333 ; \
        shr     rcx, 32             ;  \
        sub     eax, ecx            ;   | All of this is division
        shr     eax                 ;   | by 31 but faster
        add     eax, ecx            ;  /
        shr     eax, 4              ; /
        ret
```

```
u5_to_u8_naive          time:   [11.108 µs 11.147 µs 11.195 µs]
u5_to_u8_naive_v2       time:   [1.3806 µs 1.3848 µs 1.3898 µs]
u5_to_u8_naive_v3       time:   [614.04 ns 615.98 ns 618.32 ns]
u5_to_u8_int            time:   [580.73 ns 582.60 ns 584.85 ns]
u5_to_u8_bcdec          time:   [527.47 ns 531.42 ns 536.16 ns]
```

LLVM performs an optimization that replaces division by constant (in out case 31) with a multiplication and a shift. While this is faster than a division, it also makes the assembly harder to read... What don't we do for speed?

But is this fastest we can go with pure integer arithmetic?

## Rounded division with magic constants

While talking to the maintainer of the `image` crate, he mentioned the Rust source port of [the `bcdec` C library](https://github.com/iOrange/bcdec). So I took a peek at the code and found that it used this for the 5 bit to 8 bit conversion:

```rust
fn u5_to_u8(x: u16) -> u8 {
    ((x * 527 + 23) >> 6) as u8
}
```

```asm
u5_to_u8:
        imul    eax, edi, 527 ; eax = x * 527
        add     eax, 23       ; eax = eax + 23
        shr     eax, 6        ; eax = eax >> 6
        ret
```

This is magic. In only 3 instructions, this function converts all 5-bit values of `x` to 8-bit values, perfectly rounded and without division.

To understand how this work, let's look at math. We will add a new parameter $s$ that will be the amount we shift the result to the right. Mathematically, `x >> s` is just $\lfloor x / 2^s \rfloor$. We also define $m = 2^n-1$.

$$
\begin{split}
round(\frac{x}{m} \cdot 255) &= \lfloor \frac{x \cdot 255 + m/2}{m} \rfloor \\
                             &= \lfloor \frac{(x \cdot 255 + m/2)*2^s/m}{2^s} \rfloor \\
                             &= \lfloor \frac{x \cdot 255 \cdot 2^s / m + 2^{s-1}}{2^s} \rfloor \\
\end{split}
$$

Let's substitute $m = 31$ and $s = 6$:

$$
\lfloor \frac{x \cdot 526.4516 + 32}{2^6} \rfloor
$$

Now we can kind of see where the magic number 527 comes from. But 23? That's still a mystery.

### Analzing the expression

Since the magic code has the form `(x * f + a) >> s`, let's see what we can find out by simply analyzing the expression.

Let's define the variables first:

-   $S \in \N, S \ne 0$ is the maximum input number.
-   $T \in \N, T \ne 0$ is the maximum output number.

What are want a values for $f \in \N_0$, $a \in \N_0$, and $s \in \N_0$ such that:

$$
\lfloor \frac{x \cdot f + a}{2^s} \rfloor = round(\frac{x}{S} \cdot T), \space \forall x \in \N_0, 0 \le x \le S
$$

Here's what we know:

1. $f \ne 0$. Showing this formally is a bit tedious, but the basic idea is that if $f = 0$, then we can only satisfy the above equation for a single value of $x$. However, since there always at least 2 possible values of $x$, $f = 0$ cannot be part of a valid solution.
1. There are infinitely many triples $(f, a, s)$ that satisfy the equation. If a triple $(f, a, s)$ is a solution, then $(f \cdot 2, a \cdot 2, s+1)$ is also a solution.

Since there are infinitely many solutions, let's require our solution to be minimal. So given a solution $(f, a, s)$, there is no solution $(f', a', s')$ such that $(f' \cdot 2, a' \cdot 2, s' + 1) = (f, a, s)$.

With this out of the way, let's continue:

3. $s > 0 \implies f \text{ is odd}$. If $f$ was even, then $(f/2,\lfloor a/2 \rfloor, s-1)$ would also be a solution, which contradicts our requirement for minimal solutions. Here's why this is the case if $f$ is even:

    $$
    \lfloor \frac{x \cdot f + a}{2^s} \rfloor = \lfloor \frac{x \cdot f/2 + a/2}{2^{s-1}} \rfloor = \lfloor \frac{x \cdot f/2 + \lfloor a/2 \rfloor}{2^{s-1}} \rfloor
    $$

    For a proof of the last equality, see the appendix.

4. $a < 2^s$. If $a \ge 2^s$, then for $x=0$ we get:

    $$
    \lfloor \frac{x \cdot f + a}{2^s} \rfloor
    = \lfloor \frac{a}{2^s} \rfloor
    > 1
    \ne 0
    = round(0)
    = round(\frac{x}{S} \cdot T)
    $$

5. From 4), it trivially follows that $s = 0 \implies a = 0$.

6. We can establish bounds for $f$. Let's substitute $x=S$:

    $$
    \lfloor \frac{S \cdot f + a}{2^s} \rfloor = T = round(\frac{S}{S} \cdot T)
    $$

    Using $z-1 < \lfloor z \rfloor \le z, \forall z\in \R$, we get 2 inequalities:

    $$
    \frac{S \cdot f + a}{2^s} \ge T \text{ and } \frac{S \cdot f + a}{2^s} - 1 < T
    $$

    Rearranging for $f$, we get:

    $$
    \frac{T \cdot 2^s - a}{S} \le f < \frac{(T+1) \cdot 2^s - a}{S}
    $$

    Finally, we use $0 \le a < 2^s$ and $s=0 \implies a=0$ to remove $a$ from the inequalities:

    $$
    \begin{split}
    s = 0 &\implies \frac{T}{S} \le f < \frac{T+1}{S} \implies f = \frac{T}{S} \\
    s > 0 &\implies \frac{(T-1) \cdot 2^s}{S} < f < \frac{(T+1) \cdot 2^s}{S} \\
          &\implies f = \frac{T \cdot 2^s}{S} \pm \frac{2^s}{S} \\
    \end{split}
    $$

    From the "bound" for $s=0$ we can follow that $T \text{ is divisible by }S \implies (f,a,s)=(T/S,0,0)$ is a solution.

    Unfortunately, the bounds are not very tight. In the $s>0$ case, the bounds grow exponentially with $s$.

7. We can improve the bound by giving up on the minimal solution requirement. If we instead substitute $x=k \cdot S, k\in\N,k>0$, we get the bounds:

    $$
    \begin{split}
    s = 0 &\implies f = \frac{T}{S} \\
    s > 0 &\implies \frac{(k \cdot T-1) \cdot 2^s}{k \cdot S} < f < \frac{(k \cdot T+1) \cdot 2^s}{k \cdot S} \\
          &\implies f = \frac{T \cdot 2^s}{S} \pm \frac{2^s}{k \cdot S} \\
    \end{split}
    $$

    If we let $k \to \infin$, then the $s>0$ case converges to $f = T \cdot 2^s/S$ as well. Since we know that $k \to \infin$ makes the bounds of $f$ converge, we can choose a value $k \ge 1$ such that the bound is as small as possible while still containing an odd integer. Since the distance of the lower and upper bound from $T \cdot 2^s/S$ is the same, we know that the optimal $f$ is an odd integer closest to $T \cdot 2^s/S$. Note that there can be 2 such values for $f$ if $T \cdot 2^s/S$ is an integer.

    While I cannot proof this, I claim that choosing a closest odd integer for $f$ is still a minimal solution, if no $s=0$ solution exists. My basis for this claim are experiments I did where using the full bounds for $f$ always gave the same solution as choosing close odd integers.

With this, we can now understand the magic number 527 from the 5 bit to 8 bit conversion better. 527 is closest odd integer to $255 * 2^6 / 31 = 526.45$.

### When in doubt: Brute force

Since the magic code has the form `(x * f + a) >> s`, let's see what we can find out by simply analyzing the expression. Here's what we know:

$$
\lfloor \frac{x \cdot f + a}{2^s} \rfloor = round(x/S \cdot T)
$$

-   `f`, `a`, and `s` are all unsigned integers. Since we are doing arithmetic on unsigned integers, we require them to be as well.
-   `s` is less than 64. This is simply a practical limitation. If `s` is 64 or greater, we need at least 128-bit integers to represent the possible values of `(x * f + a)`.

Since the magic code has the form `(x * f + a) >> s`, I wrote a simple JavaScript program to find values for `f`, `a`, and `s` such that `(x * f + a) >> s == Math.round(x * 255 / 31)` for all `x` in the range 0-31. It works as follows:

```javascript
for (let s = 0; s < 32; s++) {
    let fRadius = 8; // arbitrary search radius
    let fBase = Math.round((255 / 31) * 2 ** s);
    for (let f = fBase - fRadius; f <= fBase + fRadius; f++) {
        for (let a = 0; a < 2 ** s; a++) {
            // check whether the values work for all x in 0-31
            if (exhaustiveCheck(f, a, s)) {
                console.log(`f: ${f}, a: ${a}, s: ${s}`);
                return;
            }
        }
    }
}
console.log(`nothing found`);
```

Sure enough, after less than a second, the program found the magic numbers:

```
f: 527, a: 23, s: 6
```

### Generalizing

While playing around with the brute force program, I noticed that it can find magic numbers for arbitrary conversion function. So it can find constants to remap any number 0-S to a number 0-T, where S and T are arbitrary integers >= 2.

If you want to know the constants for a specific conversion, here's a little tool to brute force them for you. I implemented a few optimizations, so it should find most constants in less than a second if $S+T<2^{20}$.

```json:custom
{
    "component": "conversion-brute-force"
}
```

## Appendix

Proof for $\lfloor \frac{a + \lfloor b/2 \rfloor + 0.5}{b} \rfloor =  \lfloor \frac{a + \lfloor b/2 \rfloor}{b} \rfloor$ for $a,b \in N_0, b \neq 0$:

The lastly, we try to make $b/2$ an integer. We need to consider 2 cases for this:

1.  $b$ is even. In this case, $b/2$ is an integer.
2.  $b$ is odd. In this case, $b/2 = \lfloor b/2 \rfloor + 0.5$. Let's put this into the formula:

    $$
    \lfloor \frac{a + \lfloor b/2 \rfloor + 0.5}{b} \rfloor =  \lfloor \frac{a + \lfloor b/2 \rfloor}{b} \rfloor
    $$

    Why is this equal? If we have a fraction of the $\lfloor (a + c) / b \rfloor, \space a,b,c \in \R, b>0,c>0$, then $\lfloor (a + c) / b \rfloor \neq \lfloor a / b \rfloor$ if and only if $\exist k \in \N : a \lt k \cdot b \le a+c$.

    1. If such a $k$ exists, then we know that $\lfloor a/b \rfloor \le k-1 < k \le \lfloor (a+c)/b \rfloor$. Therefore, $\lfloor (a+c)/b \rfloor \neq \lfloor a/b \rfloor$.
    2. If $\lfloor (a+c)/b \rfloor \neq \lfloor a/b \rfloor$, then $\lfloor (a+c)/b \rfloor > \lfloor a/b \rfloor$ because $c>0$. Then $k = \lfloor a/b \rfloor + 1$ has the properties we require:
        1. $a < k \cdot b \iff a/b < k \iff a/b < \lfloor a/b \rfloor + 1$, which is true, because $\forall x \in \R : x < \lfloor x \rfloor + 1$.
        2. $k \cdot b \le a+c \iff k \le (a+c)/b \iff \lfloor a/b \rfloor + 1 \le (a+c)/b$. Since $\lfloor x \rfloor$ returns integers and $\lfloor a/b \rfloor < \lfloor (a+c)/b \rfloor$, we know that $\lfloor a/b \rfloor + 1 \le \lfloor (a+c)/b \rfloor$. Putting this together, we get $\lfloor a/b \rfloor + 1 \le \lfloor (a+c)/b \rfloor \le (a+c)/b$.
