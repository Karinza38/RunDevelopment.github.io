---
datePublished: 2024-06-08
draft: true
---

# Rounding numbers: Old new tricks

I recently implemented a new DDS decoder for [the `image` crate](https://github.com/image-rs/image). DDS is a container format that supports a variety of image formats (compressed and uncompressed) with the purpose of storing textures, volumes, cubemaps, and more for games and 3D applications. What's interesting about these image formats is that [the specification](https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm#Chapter19Contents) is written in terms of floating point numbers. This presents an interesting optimization problem for decoders that output 8-bit-per-channel images.

This article will focus on the `B5G6R5_UNORM` format. This is a 16-bit-per-pixel uncompressed (but quantized) RGB format. The R and B channels are 5 bits each, and the G channel is 6 bits. The formula for converting a n-bit number $x$ to 8 bit is:

$$
round(\frac{x}{2^n - 1} \cdot 255)
$$

Simple enough, here's the naive Rust implementation for converting a 5-bit number to an 8-bit number:

```rust
fn u5_to_u8_naive(x: u16) -> u8 {
    (x as f32 / 31.0 * 255.0).round() as u8
}
```

However, while talking to the maintainer of the `image` crate, he pointed me towards the direction of [the `bcdec` C library](https://github.com/iOrange/bcdec). So I took a peak at their code and found that they used this for the 5 bit to 8 bit conversion (here, translated to Rust):

```rust
fn u5_to_u8_bcdec(x: u16) -> u8 {
    ((x * 527 + 23) >> 6) as u8
}
```

Somehow, this random collection of operations produces the same results as the floating point version (for all 5-bit values of `x`), and it's about **20x** faster. C program(mer)s are just built different.

In this article, we will optimize our naive 5-to-8-bit conversion function all the way to the `bcdec` version. We'll also generalize the `bcdec` version to convert any `0..=S` number to any `0..=T` number for arbitrary `S` and `T`.

## Benchmarking

Before we start optimizing, let's define a benchmark.

Since the range of input values is very small (32 values), we'll just fill a `Vec<u16>` with 1024 random values between 0 and 31 and convert them to 8-bit values. Since our function is very simple, this means that we're benchmarking not only the function, but also how well the compiler can vectorize it. This is very close to what the DDS decoder I made does, so it decently represents a real-world use case.

<details>
<summary>The code</summary>

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use rand::prelude::*;
use rounding_rs::*;

fn define_benchmark(c: &mut Criterion, name: &str, f: impl Fn(u16) -> u8) {
    let mut rng = rand::thread_rng();
    const N: usize = 1024;
    let samples: Vec<u16> = black_box((0..N).map(|_| rng.gen_range(0..=31)).collect());
    let mut output = [0u8; N];

    c.bench_function(name, |b| {
        b.iter(|| {
            for (x, out) in samples.iter().zip(output.iter_mut()) {
                *out = f(*x);
            }
            black_box(output);
        })
    });
}

fn round_benchmark(c: &mut Criterion) {
    define_benchmark(c, "u5_to_u8_naive", u5_to_u8_naive);
    define_benchmark(c, "u5_to_u8_bcdec", u5_to_u8_bcdec);
}

criterion_group!(benches, round_benchmark);
criterion_main!(benches);
```

</details>

All benchmarks in this article were performed in the following environment:

-   OS: Windows 10
-   CPU: Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz
-   Rust: 1.78.0

Here are the results for the naive and `bcdec` versions. Note the _different units_.

```
u5_to_u8_naive          time:   [11.108 µs 11.147 µs 11.195 µs]
u5_to_u8_bcdec          time:   [527.47 ns 531.42 ns 536.16 ns]
```

Yep, 21.15x faster. Let's try to catch up.

## Optimizing the naive implementation

Let's start by taking a look at the assembly generated by the naive implementation. I'm using compiler explorer for this, so the assembly might be slightly different from what you get on your machine.

```rust
fn u5_to_u8_naive(x: u16) -> u8 {
    (x as f32 / 31.0 * 255.0).round() as u8
}
```

```asm
.LCPI0_0:
        .long   0x41f80000
.LCPI0_1:
        .long   0x437f0000
u5_to_u8_naive:
        push    rax
        movzx   eax, di
        cvtsi2ss        xmm0, eax                 ; xmm0 = x to f32
        divss   xmm0, dword ptr [rip + .LCPI0_0]  ; xmm0 = xmm0 / 31.0
        mulss   xmm0, dword ptr [rip + .LCPI0_1]  ; xmm0 = xmm0 * 255.0
        call    qword ptr [rip + roundf@GOTPCREL] ; xmm0 = round(xmm0)
        xorps   xmm1, xmm1                        ; xmm1 = 0.0
        maxss   xmm1, xmm0                        ; xmm1 = min(xmm1, xmm0)
        movss   xmm0, dword ptr [rip + .LCPI0_1]  ; xmm0 = 255.0
        minss   xmm0, xmm1                        ; xmm0 = max(xmm0, xmm1)
        cvttss2si       eax, xmm0                 ; convert xmm0 to u8
        pop     rcx
        ret
```

Well, that's not good. A few things to note:

1. The compiler did not optimize `/ 31.0 * 255.0` into a single multiplication.
2. `round` is a function call.
3. `as u8` does a surprising amount of work. It first clamps the float to the range 0-255, then converts it to an integer by truncation. So `f as u8` essentially does `f.clamp(0.0, 255.0).trunc() as u8`.

We can easily remove the division by defining a `const`ant for `255.0 / 31.0` and then multiplying with the constant. This is fairly trivial, so let's move on to more interesting optimizations.

Next: the call to `round`. Mathematically speaking, rounding is defined as follows:

$$
round(x) := \lfloor x + 0.5 \rfloor, \space x \in \R
$$

However, we are working with finitely precise 32-bit floating point numbers, where the result of `0.49999997 + 0.5` is `1.0`:

```rust
let a: f32 = 0.49999997;
assert!(a != 0.5);
assert!(a + 0.5 == 1.0);
assert!(a.round() == 0.0);
```

So Rust's `round` function has to do quite a bit of work to get the correct result.

But let's forget about all of this complexity again, and just pretend to live a mathemagical world where $round(x) = \lfloor x + 0.5 \rfloor$.

```rust
fn u5_to_u8_naive_v2_alpha(x: u16) -> u8 {
    const FACTOR: f32 = 255.0 / 31.0;
    (x as f32 * FACTOR + 0.5).floor() as u8
}
```

But wait! As we've seen in the assembly `as u8` _truncates_ our floating point number. Since $trunc(x) = \lfloor x \rfloor$ for all $x \ge 0$, we can just remove the `floor` call:

```rust
fn u5_to_u8_naive_v2(x: u16) -> u8 {
    const FACTOR: f32 = 255.0 / 31.0;
    (x as f32 * FACTOR + 0.5) as u8
}
```

```asm
.LCPI0_0:
        .long   0x41039ce7
.LCPI0_1:
        .long   0x3f000000
.LCPI0_2:
        .long   0x437f0000
u5_to_u8_naive_v2:
        movzx   eax, di
        cvtsi2ss        xmm0, eax                ; xmm0 = x to f32
        mulss   xmm0, dword ptr [rip + .LCPI0_0] ; xmm0 = xmm0 * 8.22580624 (255 / 31)
        addss   xmm0, dword ptr [rip + .LCPI0_1] ; xmm0 = xmm0 + 0.5
        xorps   xmm1, xmm1                       ; xmm1 = 0.0
        maxss   xmm1, xmm0                       ; xmm1 = min(xmm1, xmm0)
        movss   xmm0, dword ptr [rip + .LCPI0_2] ; xmm0 = 255.0
        minss   xmm0, xmm1                       ; xmm0 = max(xmm0, xmm1)
        cvttss2si       eax, xmm0                ; convert xmm0 to u8
        ret
```

```
u5_to_u8_naive          time:   [11.108 µs 11.147 µs 11.195 µs]
u5_to_u8_naive_v2       time:   [1.3806 µs 1.3848 µs 1.3898 µs]
u5_to_u8_bcdec          time:   [527.47 ns 531.42 ns 536.16 ns]
```

That's a lot better. Our optimizations made the naive implementation 8x faster. We got a lot more competitive with the `bcdec` version, but we're still not quite there.

The unnecessary clamping is next. Rust only performs the clamping to be safe, because it doesn't know that the floating point value is already between 0 and 255(.999). But we know that. Luckily, Rust provides us with the [`f32::to_int_unchecked`](https://doc.rust-lang.org/std/primitive.f32.html#method.to_int_unchecked) method to get around this.

```rust
/// ## Safety
/// The caller must ensure that x < 32.
unsafe fn u5_to_u8_naive_v3(x: u16) -> u8 {
    debug_assert!(x < 32);
    const FACTOR: f32 = 255.0 / 31.0;
    let f = x as f32 * FACTOR + 0.5;
    unsafe { f.to_int_unchecked() }
}
```

```asm
.LCPI0_0:
        .long   0x41039ce7
.LCPI0_1:
        .long   0x3f000000
u5_to_u8_naive_v3:
        movzx   eax, di
        cvtsi2ss        xmm0, eax                ; xmm0 = x to f32
        mulss   xmm0, dword ptr [rip + .LCPI0_0] ; xmm0 = xmm0 * 8.22580624 (255 / 31)
        addss   xmm0, dword ptr [rip + .LCPI0_1] ; xmm0 = xmm0 + 0.5
        cvttss2si       eax, xmm0                ; convert xmm0 to u8
        ret
```

```
u5_to_u8_naive          time:   [11.108 µs 11.147 µs 11.195 µs]
u5_to_u8_naive_v2       time:   [1.3806 µs 1.3848 µs 1.3898 µs]
u5_to_u8_naive_v3       time:   [614.04 ns 615.98 ns 618.32 ns]
u5_to_u8_bcdec          time:   [527.47 ns 531.42 ns 536.16 ns]
```

We're almost caught up. The `bcdec` version is still faster, but we're only 1.17x slower now.

However, we did have to use `unsafe`, which is never nice. Since the floating-point-to-integer conversion is the reason we needed `unsafe` in the first place, let's avoid using floating point altogether.

## Rounded division for unsigned integers

Before we tackle the 5 bit to 8 bit conversion, let's focus on rounded integer division first. Specifically, this:

$$
round(\frac{a}{b}), \space a, b \in \N_0, \space b \neq 0
$$

Using $round(x) = \lfloor x + 0.5 \rfloor$, we get:

$$
\begin{split}
round(\frac{a}{b}) & = \lfloor \frac{a}{b} + 0.5 \rfloor \\
                   & = \lfloor \frac{a}{b} + \frac{b/2}{b} \rfloor \\
                   & = \lfloor \frac{a + b/2}{b} \rfloor \\
                   & = \lfloor \frac{a + \lfloor b/2 \rfloor}{b} \rfloor \\
\end{split}
$$

Proof for the last step can be found in the appendix.

Since we now have integers in the denominator and divisor, we can use the standard integer division (which performs truncation):

```rust
fn div_rounded(a: u32, b: u32) -> u32 {
    (a + (b >> 1)) / b
}
```

Using this as a basis, we can implement the 5 bit to 8 bit conversion using only integer arithmetic:

```rust
fn u5_to_u8_int(x: u32) -> u8 {
    ((x * 255 + (31 >> 1)) / 31) as u8
}
```

```asm
u5_to_u8_int:
        mov     eax, edi            ; eax = x
        shl     eax, 8              ; eax = x << 8 (= x * 256)
        sub     eax, edi            ; eax = eax - x
        add     eax, 15             ; eax = eax + 15
        imul    rcx, rax, 138547333 ; \
        shr     rcx, 32             ;  \
        sub     eax, ecx            ;   | All of this is division
        shr     eax                 ;   | by 31 but faster
        add     eax, ecx            ;  /
        shr     eax, 4              ; /
        ret
```

```
u5_to_u8_naive          time:   [11.108 µs 11.147 µs 11.195 µs]
u5_to_u8_naive_v2       time:   [1.3806 µs 1.3848 µs 1.3898 µs]
u5_to_u8_naive_v3       time:   [614.04 ns 615.98 ns 618.32 ns]
u5_to_u8_int            time:   [580.73 ns 582.60 ns 584.85 ns]
u5_to_u8_bcdec          time:   [527.47 ns 531.42 ns 536.16 ns]
```

LLVM performs an optimization that replaces division by constant (in out case 31) with a multiplication and a shift. While this is faster than a division, it also makes the assembly harder to read... What don't we do for speed?

But is this fastest we can go with pure integer arithmetic?

## Rounded division with magic constants

While talking to the maintainer of the `image` crate, he mentioned the Rust source port of [the `bcdec` C library](https://github.com/iOrange/bcdec). So I took a peek at the code and found that it used this for the 5 bit to 8 bit conversion:

```rust
fn u5_to_u8(x: u16) -> u8 {
    ((x * 527 + 23) >> 6) as u8
}
```

```asm
u5_to_u8:
        imul    eax, edi, 527 ; eax = x * 527
        add     eax, 23       ; eax = eax + 23
        shr     eax, 6        ; eax = eax >> 6
        ret
```

This is magic. In only 3 instructions, this function converts all 5-bit values of `x` to 8-bit values, perfectly rounded and without division.

To understand how this work, let's look at math. We will add a new parameter $s$ that will be the amount we shift the result to the right. Mathematically, `x >> s` is just $\lfloor x / 2^s \rfloor$. We also define $m = 2^n-1$.

$$
\begin{split}
round(\frac{x}{m} \cdot 255) &= \lfloor \frac{x \cdot 255 + m/2}{m} \rfloor \\
                             &= \lfloor \frac{(x \cdot 255 + m/2)*2^s/m}{2^s} \rfloor \\
                             &= \lfloor \frac{x \cdot 255 \cdot 2^s / m + 2^{s-1}}{2^s} \rfloor \\
\end{split}
$$

Let's substitute $m = 31$ and $s = 6$:

$$
\lfloor \frac{x \cdot 526.4516 + 32}{2^6} \rfloor
$$

Now we can kind of see where the magic number 527 comes from. But 23? That's still a mystery.

### Analzing the expression

Since the magic code has the form `(x * f + a) >> s`, let's see what we can find out by simply analyzing the expression.

Let's define the variables first:

-   $S \in \N, S \ne 0$ is the maximum input number.
-   $T \in \N, T \ne 0$ is the maximum output number.

What are want values for $f \in \N_0$, $a \in \N_0$, and $s \in \N_0$ such that:

$$
\lfloor \frac{x \cdot f + a}{2^s} \rfloor = round(\frac{x}{S} \cdot T), \space \forall x \in \N_0, 0 \le x \le S
$$

Here's what we know:

1. $f \ne 0$. Showing this formally is a bit tedious, but the basic idea is that if $f = 0$, then we can only satisfy the above equation for a single value of $x$. However, since there always at least 2 possible values of $x$, $f = 0$ cannot be part of a valid solution.
2. There are infinitely many triples $(f, a, s)$ that satisfy the equation. If a triple $(f, a, s)$ is a solution, then $(f \cdot 2, a \cdot 2, s+1)$ and $(f \cdot 2, a \cdot 2 + 1, s+1)$ are also solutions.

Since there are infinitely many solutions, let's require our solution to be minimal. A solution $(f, a, s)$ is minimal, iff $(f/2, \lfloor a/2 \rfloor, s-1)$ is not a solution.

With this out of the way, let's continue:

3. $s > 0 \implies f \text{ is odd}$. If $f$ was even, then $(f/2,\lfloor a/2 \rfloor, s-1)$ would also be a solution, which contradicts our requirement for minimal solutions. Here's why this is the case if $f$ is even:

    $$
    \lfloor \frac{x \cdot f + a}{2^s} \rfloor = \lfloor \frac{x \cdot f/2 + a/2}{2^{s-1}} \rfloor = \lfloor \frac{x \cdot f/2 + \lfloor a/2 \rfloor}{2^{s-1}} \rfloor
    $$

    For a proof of the last equality, see the appendix.

4. $a < 2^s$. If $a \ge 2^s$, then for $x=0$ we would get:

    $$
    \lfloor \frac{x \cdot f + a}{2^s} \rfloor
    = \lfloor \frac{a}{2^s} \rfloor
    > 1
    \ne 0
    = round(0)
    = round(\frac{x}{S} \cdot T)
    $$

5. From 4), it trivially follows that $s = 0 \implies a = 0$.

6. We can establish bounds for $f$. Let's substitute $x=S$:

    $$
    \lfloor \frac{S \cdot f + a}{2^s} \rfloor = T = round(\frac{S}{S} \cdot T)
    $$

    Using $z-1 < \lfloor z \rfloor \le z, \forall z\in \R$, we get 2 inequalities:

    $$
    \frac{S \cdot f + a}{2^s} \ge T \text{ and } \frac{S \cdot f + a}{2^s} - 1 < T
    $$

    Rearranging for $f$, we get:

    $$
    \frac{T \cdot 2^s - a}{S} \le f < \frac{(T+1) \cdot 2^s - a}{S}
    $$

    Finally, we use $0 \le a < 2^s$ and $s=0 \implies a=0$ to remove $a$ from the inequalities:

    $$
    \begin{split}
    s = 0 &\implies \frac{T}{S} \le f < \frac{T+1}{S} \implies f = \frac{T}{S} \\
    s > 0 &\implies \frac{(T-1) \cdot 2^s}{S} < f < \frac{(T+1) \cdot 2^s}{S} \\
    \end{split}
    $$

    From the "bound" for $s=0$ we can follow that $T \text{ is divisible by }S \implies (f,a,s)=(T/S,0,0)$ is a solution.

    Unfortunately, the bounds are not very tight. In the $s>0$ case, the bounds grow exponentially with $s$.

7. We can improve the bound by giving up on the minimal solution requirement. If we instead substitute $x=k \cdot S, k\in\N,k>0$, we get the bounds:

    $$
    \begin{split}
    s = 0 &\implies f = \frac{T}{S} \\
    s > 0 &\implies \frac{(k \cdot T-1) \cdot 2^s}{k \cdot S} < f < \frac{(k \cdot T+1) \cdot 2^s}{k \cdot S} \\
          &\iff \frac{T \cdot 2^s}{S} - \frac{2^s}{k \cdot S} < f < \frac{T \cdot 2^s}{S} + \frac{2^s}{k \cdot S} \\
    \end{split}
    $$

    If we let $k \to \infin$, then the $s>0$ case converges to $f = T \cdot 2^s/S$ as well. Since we know that $k \to \infin$ makes the bounds of $f$ converge, we can choose a value $k \ge 1$ such that the bound is as small as possible while still containing an odd integer. Since the distance of the lower and upper bound from $T \cdot 2^s/S$ is the same, we know that the optimal $f$ is an odd integer closest to $T \cdot 2^s/S$. Note that there can be 2 such values for $f$ if $T \cdot 2^s/S$ is an even integer.

With this, we can now understand the magic number 527 from the 5 bit to 8 bit conversion better. 527 is closest odd integer to $255 * 2^6 / 31 = 526.45$.

From my experimentation, I also discovered the following properties:

8. There are multiple minimal solutions, and there are multiple minimal solutions with the same values for $f$ and $s$.

    E.g. for $S=31, T=255$, all solutions with $s<10$ are (all solutions with an odd $f$ are minimal):

    - $f=527, a=23, s=6$
    - $f=1053, a \in \set{60, 61,62,63, 64}, s=7$
    - $f=1054, a \in \set{46, 47}, s=7$
    - $f=2105, a=140, s=8$
    - $f=2106, a \in \set{120, ..., 129}, s=8$
    - $f=2107, a \in \set{100, ..., 118}, s=8$
    - $f=2108, a \in \set{92, 93,94, 95}, s=8$
    - $f=4210, a \in \set{280, 281}, s=9$
    - $f=4211, a \in \set{260, ..., 270}, s=9$
    - $f=4212, a \in \set{240, ..., 259}, s=9$
    - $f=4213, a \in \set{220, ..., 248}, s=9$
    - $f=4214, a \in \set{200, ..., 237}, s=9$
    - $f=4215, a \in \set{191, ..., 215}, s=9$
    - $f=4216, a \in \set{184, ..., 191}, s=9$

    There can even be multiple minimal solutions with the the smallest $s$ value. E.g. the solutions with the smallest $s$ for $S=123,T=1000$ are:

    - $f=8325, a \in \set{518,...,530}, s=10$

### Generalizing the expression

In the above analysis, we did not use 2 properties of our equation:

$$
\lfloor \frac{x \cdot f + a}{2^s} \rfloor = round(\frac{x}{S} \cdot T), \space \forall x \in \N_0, 0 \le x \le S
$$

1. The bounds of $x$. 1) only used there are at least 2 possible values of $x$.
2. The properties of the $round$ function. We only used the property $round(i) = i, i \in \N$, but there are other functions that satisfy this property.

So let's modify the equation to:

$$
\lfloor \frac{x \cdot f + a}{2^s} \rfloor = R(\frac{x}{S} \cdot T), \space \forall x \in \N_0, 0 \le x \le U
$$

Where $U \in \N,U>0$ and $R$ is a function that satisfies the following properties:

1. $R(i) = i, \forall i \in \N_0$,
2. $R(x) \in \N, \forall x\in\R$, and
3. $R$ is monotonically increasing.

Basically, we want $R$ to be a rounding function, but we don't require a specific rounding function. E.g. possible functions are $R(x) = round(x)$, $R(x) = \lfloor x \rfloor$, and $R(x) = \lceil x \rceil$.

We now have something very powerful on our hands. If we can find the right constants for $(f, a, s)$, we can multiply any number $x \in \set{0,1,...,U}$ with an arbitrary fraction $T/S$ and round it to an integer with an arbitrary rounding function $R$. We just need to find the right constants.

### Brute forcing magic constants

Since we've already know quite a bit about the constants we want, brute forcing them is quite straightforward. Here's the basic algorithm in Rust-like pseudo code:

```rust
for s in 0..64 {
    for f in get_optimal_factors(s) {
        for a in 0..(1 << s) {
            if exhaustive_check(f, a, s) {
                return (f, a, s);
            }
        }
    }
}

fn exhaustive_check(f: uint, a: uint, s: uint) -> bool {
    for x in 0..=U {
        if (x * f + a) >> s != get_expected(x) {
            return false;
        }
    }
    return true;
}

fn get_expected(x: uint) -> uint {
    return R((x * T) as decimal / S);
}
```

`get_optimal_factors` returns the optimal values for $f$ for a given $s$ as described in 7).

While this works, it's quite slow since the number of `exhaustive_check`s we need to do grows exponentially with $s$. However, we can optimize this **a lot** using two observations I made:

1. If $(f,a,s)$ is not a solution, because it doesn't work for a specific $x$, then $(f,a+1,s)$ will likely also not work for the same $x$. This means that we can often skip checking the full range by keeping track of the value of $x$ that caused `exhaustive_check` to reject the previous solution.
2. Only a few specific values of $x$ ever cause `exhaustive_check` to reject a solution. So by keeping track of all values of $x$ that previously caused a rejection, we can check these values before checking the full range.

Lastly, we can optimize the values of $a$ that we check. Since we keep track of values that are very likely to reject a solution, we can use a binary-search-like algorithm to find the smallest and largest values of $a$ that for a specific value of $f$.

### Playground

I implemented the above algorithm in TypeScript for this website, so feel free to play around with it. Thanks to the above optimizations, it's fairly fast and can find the magic constants for most values of $S+T+U<100'000$ in less than a second.

```json:custom
{
    "component": "conversion-brute-force"
}
```

## Beating the compiler at its own game

Remember how the compiler replaced the `/ 31` with a multiplication and some other instructions? We can do the same thing with our magic constants.

We select $S=31, T=1, U=255$ and use $R(x) = \lfloor x \rfloor$ as the rounding function.

## Appendix

Proof for $\lfloor \frac{a + \lfloor b/2 \rfloor + 0.5}{b} \rfloor =  \lfloor \frac{a + \lfloor b/2 \rfloor}{b} \rfloor$ for $a,b \in N_0, b \neq 0$:

The lastly, we try to make $b/2$ an integer. We need to consider 2 cases for this:

1.  $b$ is even. In this case, $b/2$ is an integer.
2.  $b$ is odd. In this case, $b/2 = \lfloor b/2 \rfloor + 0.5$. Let's put this into the formula:

    $$
    \lfloor \frac{a + \lfloor b/2 \rfloor + 0.5}{b} \rfloor =  \lfloor \frac{a + \lfloor b/2 \rfloor}{b} \rfloor
    $$

    Why is this equal? If we have a fraction of the $\lfloor (a + c) / b \rfloor, \space a,b,c \in \R, b>0,c>0$, then $\lfloor (a + c) / b \rfloor \neq \lfloor a / b \rfloor$ if and only if $\exist k \in \N : a \lt k \cdot b \le a+c$.

    1. If such a $k$ exists, then we know that $\lfloor a/b \rfloor \le k-1 < k \le \lfloor (a+c)/b \rfloor$. Therefore, $\lfloor (a+c)/b \rfloor \neq \lfloor a/b \rfloor$.
    2. If $\lfloor (a+c)/b \rfloor \neq \lfloor a/b \rfloor$, then $\lfloor (a+c)/b \rfloor > \lfloor a/b \rfloor$ because $c>0$. Then $k = \lfloor a/b \rfloor + 1$ has the properties we require:
        1. $a < k \cdot b \iff a/b < k \iff a/b < \lfloor a/b \rfloor + 1$, which is true, because $\forall x \in \R : x < \lfloor x \rfloor + 1$.
        2. $k \cdot b \le a+c \iff k \le (a+c)/b \iff \lfloor a/b \rfloor + 1 \le (a+c)/b$. Since $\lfloor x \rfloor$ returns integers and $\lfloor a/b \rfloor < \lfloor (a+c)/b \rfloor$, we know that $\lfloor a/b \rfloor + 1 \le \lfloor (a+c)/b \rfloor$. Putting this together, we get $\lfloor a/b \rfloor + 1 \le \lfloor (a+c)/b \rfloor \le (a+c)/b$.
